---
title: "Data Quality Control"
description: |
  The objective is to understand the structure of proteomic data 
  matrices, recognize common data quality issues, perform initial
  quality control checks, visualize data using PCA, boxplots,
  and heatmaps, and conduct exploratory data analysis (EDA)..
author:
  - name: Dany Mukesha
    url: https://www.firalis.com
    affiliation: Firalis
    affiliation_url: https://www.firalis.com
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
---

```{r setup-day2, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
install_if_missing <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg, dependencies = TRUE)
  }
}
required_packages <- c("tidyverse", "pheatmap", "ggplot2", "limma", "reshape2")
invisible(lapply(required_packages, install_if_missing))
library(tidyverse)
library(pheatmap)
library(ggplot2)
library(limma)
library(readr)
library(reshape2)
```

In this example. we are using the proteomic data from PXD002918 (pig model of Duchenne muscular dystrophy)

We should download the "proteinGroups.txt" file, which is present 
in most cases, when the raw is already processed. 

```{r proteomics-structure}
file_path <- "proteinGroups.txt"

protein_groups <- read_tsv(
  file_path, 
  col_types = cols(.default = "c"),  # Treat all as character initially for safety
  na = c("", "NA", "NaN")) %>%
  type_convert()  # Auto-detect numeric types

# we identify LFQ columns (they start with "LFQ intensity ")
lfq_cols <- grep("^LFQ intensity ", colnames(protein_groups), value = TRUE)

# we now have to clean up sample names from column names (e.g., "LFQ intensity WT_2d_1" -> "WT_2d_1")
sample_ids <- gsub("^LFQ intensity ", "", lfq_cols)

# we create then protein_matrix: rows = Majority protein IDs (unique proteins), columns = samples (LFQ values)
# we filter proteins quantified in >=80% samples to reduce missing data noise
quant_per_protein <- rowSums(!is.na(protein_groups[lfq_cols])) / length(lfq_cols)
good_proteins <- protein_groups$`Majority protein IDs`[quant_per_protein >= 0.8]
protein_matrix <- protein_groups %>%
  filter(`Majority protein IDs` %in% good_proteins) %>%
  select(all_of(lfq_cols)) %>%
  as.matrix()
rownames(protein_matrix) <- protein_groups$`Majority protein IDs`[match(good_proteins, protein_groups$`Majority protein IDs`)]
colnames(protein_matrix) <- sample_ids

# we Log2 transform for better distribution (common in proteomics)
protein_matrix <- log2(protein_matrix + 1)  # +1 avoids log(0)

# Create sample_metadata (For Miguel: i assume there was only one batch)
sample_metadata <- data.frame(
  sample_id = sample_ids,
  condition = ifelse(grepl("DMD", sample_ids), "DMD", "WT"),  
  batch = rep("Batch1", length(sample_ids)),  # assuming single batch for all
  timepoint = sub(".*_(\\d+[a-zA-Z]+)$", "\\1", sample_ids)  
)

# we convert timepoint to days
sample_metadata$timepoint_days <- 
  ifelse(sample_metadata$timepoint == "2d", 2,
         ifelse(sample_metadata$timepoint == "3Mo", 90, NA))

# Display structure
cat("Matrix dimensions:", dim(protein_matrix), "\n")
cat("Number of proteins:", nrow(protein_matrix), "\n")
cat("Number of samples:", ncol(protein_matrix), "\n")
cat("Number of missing values:", sum(is.na(protein_matrix)), "\n")
```

```{r proteomics-structure, message=FALSE, warning=FALSE}
library(tidyverse)

# 1. Read proteinGroups for the 2D/3D experiment -----------------------------

file_path <- "proteinGroups.txt"   # <- put the correct file name here
pg_raw <- readr::read_tsv(
  file_path,
  col_types = cols(.default = "c"),
  na = c("", "NA", "NaN")
) |>
  readr::type_convert()

# 2. Remove contaminants / reverse / site-only -------------------------------

pg_filtered <- pg_raw |>
  dplyr::filter(
    is.na(`Only identified by site`),
    is.na(Reverse),
    is.na(`Potential contaminant`)
  )

# 3. Identify intensity columns & clean sample IDs ---------------------------

intensity_cols <- grep("^Intensity ", colnames(pg_filtered), value = TRUE)

# raw column labels like "Intensity 2D,DD-1" -> "2D,DD-1"
raw_labels <- gsub("^Intensity\\s+", "", intensity_cols)

# sample_ids like "2D,DD-1" -> "2D_DD_1"
sample_ids <- raw_labels |>
  gsub(",", "_", x = _) |>
  gsub("-", "_", x = _)

# 4. Filter proteins by quantification rate (>= 80% samples) -----------------

quant_per_protein <- rowSums(!is.na(pg_filtered[intensity_cols])) /
  length(intensity_cols)

good_proteins_ids <- pg_filtered$`Majority protein IDs`[quant_per_protein >= 0.8]

pg_good <- pg_filtered |>
  dplyr::filter(`Majority protein IDs` %in% good_proteins_ids)

# 5. Build protein_matrix (same object name as in first notebook) ------------

protein_matrix <- pg_good |>
  dplyr::select(all_of(intensity_cols)) |>
  as.matrix()

rownames(protein_matrix) <- pg_good$`Majority protein IDs`
colnames(protein_matrix) <- sample_ids

# Log2 transform (common in proteomics)
protein_matrix <- log2(protein_matrix + 1)

cat("Matrix dimensions:", dim(protein_matrix), "\n")
cat("Number of proteins:", nrow(protein_matrix), "\n")
cat("Number of samples:", ncol(protein_matrix), "\n")
cat("Number of missing values:", sum(is.na(protein_matrix)), "\n")

# 6. Build sample_metadata ---------------------------------------------------
# Here we translate the MaxQuant naming into experimental factors.

sample_metadata <- data.frame(
  sample_id = sample_ids,
  raw_label = raw_labels,
  stringsAsFactors = FALSE
)

# Extract dimension (2D vs 3D)
sample_metadata$dimension <- ifelse(startsWith(sample_metadata$raw_label, "2D"), "2D", "3D")

# Extract condition (DD / HC / MD)
sample_metadata$condition <- dplyr::case_when(
  grepl("DD", sample_metadata$raw_label) ~ "DD",
  grepl("HC", sample_metadata$raw_label) ~ "HC",
  grepl("MD", sample_metadata$raw_label) ~ "MD",
  TRUE ~ NA_character_
)

# Extract level (H / L / None)
sample_metadata$level <- dplyr::case_when(
  grepl(",H-", sample_metadata$raw_label) ~ "H",
  grepl(",L-", sample_metadata$raw_label) ~ "L",
  TRUE ~ "None"
)

# Correct replicate extraction = extract the LAST number in the string
# e.g. "3D,DD,H-3" → 3
#      "2D,DD-2"   → 2
sample_metadata$replicate <- as.numeric(
  sub(".*-(\\d+)$", "\\1", sample_metadata$raw_label)
)
```

### Understanding the Data

```{r data-overview}
print(sample_metadata)
summary_stats <- data.frame(
  Sample = colnames(protein_matrix),
  Mean = apply(protein_matrix, 2, mean, na.rm = TRUE),
  Median = apply(protein_matrix, 2, median, na.rm = TRUE),
  SD = apply(protein_matrix, 2, sd, na.rm = TRUE),
  N_Missing = apply(protein_matrix, 2, function(x) sum(is.na(x)))
)
print(summary_stats)
```

### Exercise 2.1: Explore Your Data

Given a proteomic dataset, calculate:
1. Total number of proteins quantified
2. Average number of missing values per protein
3. Which sample has the most missing values?

```{r exercise-2-1-solution, class.source="fold-hide"}
cat("1. Total proteins:", nrow(protein_matrix), "\n")
missing_per_protein <- apply(protein_matrix, 1, function(x) sum(is.na(x)))
cat("2. Average missing per protein:",
    round(mean(missing_per_protein), 2), "\n")
missing_per_sample <- apply(protein_matrix, 2, function(x) sum(is.na(x)))
worst_sample <- if (all(missing_per_sample == 0)) NULL else names(which.max(missing_per_sample))
if (sum(missing_per_sample) == 0) {
  cat("3. There are no missing values in the matrix.\n")
} else {
  worst_sample <- names(which.max(missing_per_sample))
  cat("3. Sample with most missing:", worst_sample, "with", 
      max(missing_per_sample), "missing values\n")
}
```

## Module 2: Initial Quality Control {#day2-mod2}

### Missing Data Analysis

Missing data is common in proteomics. Understanding the pattern is crucial.

```{r missing-data}
missing_per_protein <- apply(protein_matrix, 1, function(x) sum(is.na(x)))
missing_per_sample <- apply(protein_matrix, 2, function(x) sum(is.na(x)))

missing_df <- melt(is.na(protein_matrix))
colnames(missing_df) <- c("Protein", "Sample", "Missing")

ggplot(missing_df, aes(x = Sample, y = Protein, fill = Missing)) +
  geom_tile() +
  scale_fill_manual(values = c("TRUE" = "red", "FALSE" = "grey90")) +
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=0.5),
        axis.ticks.y = element_blank()) +
  labs(title = "Missing Data Pattern",
       subtitle = paste0("Red = Missing (",
                        round(mean(missing_df$Missing) * 100, 1), 
                        "% total)"))
## Histogram of missing values per protein [this can be use where there are missing values]
# hist(missing_per_protein,
#      breaks = 20,
#      main = "Distribution of Missing Values per Protein",
#      xlab = "Number of Missing Values",
#      col = "steelblue")
```

### Detecting Outliers and Extreme Values

```{r outliers}
protein_df <- as.data.frame(protein_matrix)
protein_df$protein_id <- rownames(protein_df)
protein_long <- pivot_longer(protein_df,
                             cols = -protein_id,
                             names_to = "sample_id",
                             values_to = "abundance")

protein_long <- merge(protein_long, sample_metadata, by = "sample_id")

ggplot(protein_long, aes(x = sample_id, y = abundance, fill = condition)) +
  geom_boxplot(outlier.size = 0.5) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Abundance Distribution by Sample",
       x = "Sample", y = "Log2 Abundance") +
  scale_fill_brewer(palette = "Set2")

ggplot(protein_long, aes(x = abundance, color = sample_id)) +
  geom_density() +
  theme_minimal() +
  labs(title = "Density Plot of Protein Abundances",
       x = "Log2 Abundance", y = "Density") +
  theme(legend.position = "none")
```

### Batch/Timepoint Effects Detection

Batch effects are systematic non-biological variations.

```{r batch-effects}
pca_data <- t(na.omit(protein_matrix))
pca_result <- prcomp(pca_data)

pca_df <- data.frame(
  PC1 = pca_result$x[, 1],
  PC2 = pca_result$x[, 2],
  sample_id = rownames(pca_result$x)
)
pca_df <- merge(pca_df, sample_metadata, by = "sample_id")

# summarize the variance explained
var_explained <- summary(pca_result)$importance[2, 1:2] * 100

ggplot(pca_df, aes(x = PC1, y = PC2, color = condition, shape = dimension)) +
  geom_point(size = 4) +
  theme_minimal() +
  labs(title = "PCA Analysis - Timepoint Effect Detection",
       x = paste0("PC1 (", round(var_explained[1], 1), "%)"),
       y = paste0("PC2 (", round(var_explained[2], 1), "%)")) +
  scale_color_brewer(palette = "Set1")

ggplot(pca_df, aes(x = PC1, y = PC2, color = dimension, shape = level)) +
  geom_point(size = 4) +
  geom_text(aes(label = sample_id), vjust = -0.7, size = 3) +
  theme_minimal() +
  labs(title = "PCA Analysis - Biological Conditions",
       x = paste0("PC1 (", round(var_explained[1], 1), "%)"),
       y = paste0("PC2 (", round(var_explained[2], 1), "%)")) +
  scale_color_brewer(palette = "Dark2")
```

### Sample Correlation Analysis

```{r correlation, fig.height=7, fig.width=8}
## --- Sample–sample correlation heatmap (FIXED VERSION) ----------------------

# 1. Compute correlation matrix
cor_matrix <- cor(protein_matrix, use = "pairwise.complete.obs")

# 2. Build annotation dataframe (NOT a tibble!)
ann_cols <- sample_metadata[, c("condition", "dimension", "level")]
ann_cols <- as.data.frame(ann_cols)

# 3. Set rownames to match column names of cor_matrix
rownames(ann_cols) <- sample_metadata$sample_id

# 4. Define annotation colors (minimal working set)
ann_colors <- list(
  condition = c(DD = "#E41A1C", HC = "#377EB8", MD = "#4DAF4A"),
  dimension = c(`2D` = "#984EA3", `3D` = "#FF7F00"),
  level     = c(H = "#E41A1C", L = "#377EB8", None = "grey70")
)

# 5. Plot heatmap (NO breaks argument)
pheatmap::pheatmap(
  cor_matrix,
  annotation_col = ann_cols,
  annotation_row = ann_cols,
  annotation_colors = ann_colors,
  color = colorRampPalette(c("blue", "white", "red"))(50),
  main = "Sample–sample correlation"
)

```

### Exercise 2.2: Quality Control Checks

Perform QC on the provided dataset:
1. Calculate the percentage of proteins with >50% missing values
2. Identify if there are any outlier samples (median abundance far from others)
3. Check for batch/timepoint effects using PCA

```{r exercise-2-2-solution, class.source="fold-hide"}
# Solution
# 1. Proteins with >50% missing
missing_pct <- apply(protein_matrix, 1, function(x) sum(is.na(x)) / length(x))
high_missing <- sum(missing_pct > 0.5)
cat("Proteins with >50% missing:", high_missing,
    "(", round(high_missing / nrow(protein_matrix) * 100, 1), "%)\n")
# 2. Outlier samples based on median [THIS SHOULD BE REVISED/ PROBABLY REMOVED]
sample_medians <- apply(protein_matrix, 2, median, na.rm = TRUE)
median_overall <- median(sample_medians)
mad_overall <- mad(sample_medians)
outliers <- abs(sample_medians - median_overall) > 3 * mad_overall
if (any(outliers)) {
  cat("Outlier samples:", names(sample_medians)[outliers], "\n")
} else {
  cat("No outlier samples detected\n")
}
# 3. Batch effects - already shown in PCA above
cat("Check PCA plot above for batch effect visualization\n")
```

## Module 3: Exploratory Data Analysis (EDA) {#day2-mod3}

### Distribution of Intensities

```{r intensity-distribution}
# Histogram of all values [TO BE REVISED]
ggplot(protein_long, aes(x = abundance)) +
  geom_histogram(bins = 50, fill = "steelblue", color = "black", alpha = 0.7) +
  theme_minimal() +
  labs(title = "Distribution of Protein Abundances",
       x = "Log2 Abundance", y = "Frequency")
# Violin plots by condition
ggplot(protein_long, aes(x = condition, y = abundance, fill = condition)) +
  geom_violin() +
  geom_boxplot(width = 0.1, fill = "white", outlier.size = 0.5) +
  theme_minimal() +
  labs(title = "Abundance Distribution by Condition",
       x = "Condition", y = "Log2 Abundance") +
  scale_fill_brewer(palette = "Set2")
```

### Hierarchical Clustering

NOTE: The row with zero variance after imputation, or

values become constant after removing “880_wt_2d”.

```{r clustering, eval}
complete_proteins <- rowSums(is.na(protein_matrix)) < ncol(protein_matrix) * 0.3
filtered_matrix <- protein_matrix[complete_proteins, ]

filtered_matrix <- filtered_matrix[rowSums(is.na(filtered_matrix)) < ncol(filtered_matrix), ]

filtered_matrix <- filtered_matrix[
  apply(filtered_matrix, 1, function(x) sd(x, na.rm = TRUE) > 0),
]

for (i in 1:nrow(filtered_matrix)) {
  missing_idx <- is.na(filtered_matrix[i, ])
  if (any(missing_idx)) {
    row_mean <- mean(filtered_matrix[i, ], na.rm = TRUE)
    if (is.finite(row_mean)) {
      filtered_matrix[i, missing_idx] <- row_mean
    }
  }
}

filtered_matrix <- filtered_matrix[, !colnames(filtered_matrix) %in% "880_wt_2d"]

filtered_matrix <- filtered_matrix[
  apply(filtered_matrix, 1, function(x) sd(x, na.rm = TRUE) > 0),
]

filtered_matrix <- filtered_matrix[
  !apply(filtered_matrix, 1, function(x) any(is.na(x) | is.nan(x) | is.infinite(x))),
]

annotation_col <- sample_metadata[, c("condition", "batch", "timepoint")]
rownames(annotation_col) <- sample_metadata$sample_id

pheatmap(filtered_matrix,
         scale = "row",
         clustering_distance_rows = "euclidean",
         clustering_distance_cols = "euclidean",
         annotation_col = annotation_col,
         show_rownames = FALSE,
         main = "Hierarchical Clustering of Samples",
         color = colorRampPalette(c("blue", "white", "red"))(50))

```

### Sample Similarity Analysis

```{r similarity}
# Calculate Euclidean distances between samples
sample_dist <- dist(t(filtered_matrix))
sample_dist_matrix <- as.matrix(sample_dist)
# Heatmap of distances
pheatmap(sample_dist_matrix,
         annotation_col = annotation_col,
         annotation_row = annotation_col,
         main = "Sample-Sample Distance Matrix",
         color = colorRampPalette(c("red", "white"))(50))
# MDS plot (alternative to PCA)
mds_result <- cmdscale(sample_dist, k = 2)
mds_df <- data.frame(
  MDS1 = mds_result[, 1],
  MDS2 = mds_result[, 2],
  sample_id = colnames(filtered_matrix)
)
mds_df <- merge(mds_df, sample_metadata, by = "sample_id")
ggplot(mds_df, aes(x = MDS1, y = MDS2, color = condition, shape = batch)) +
  geom_point(size = 4) +
  theme_minimal() +
  labs(title = "MDS Plot of Sample Similarity",
       x = "MDS Dimension 1", y = "MDS Dimension 2") +
  scale_color_brewer(palette = "Dark2")
```

### Coefficient of Variation Analysis

```{r cv-analysis}
# Calculate CV for each protein
calculate_cv <- function(x) {
  (sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)) * 100
}
cv_by_condition <- protein_long %>%
  group_by(protein_id, condition) %>%
  summarise(cv = calculate_cv(abundance), .groups = "drop")
# Plot CV distribution
ggplot(cv_by_condition, aes(x = cv, fill = condition)) +
  geom_histogram(bins = 30, alpha = 0.7, position = "identity") +
  theme_minimal() +
  labs(title = "Coefficient of Variation Distribution",
       x = "CV (%)", y = "Count") +
  scale_fill_brewer(palette = "Set2") +
  facet_wrap(~ condition, ncol = 1)
# Summary statistics
cv_summary <- cv_by_condition %>%
  group_by(condition) %>%
  summarise(
    mean_cv = mean(cv, na.rm = TRUE),
    median_cv = median(cv, na.rm = TRUE),
    sd_cv = sd(cv, na.rm = TRUE)
  )
print(cv_summary)
```

### Exercise 2.3: Complete EDA

Perform a complete exploratory analysis:
1. Create a report summarizing data quality
2. Identify the top 10 most variable proteins
3. Check if samples cluster by biological condition

```{r exercise-2-3-solution, class.source="fold-hide"}
# Solution
# 1. Data quality report
cat("=== DATA QUALITY REPORT ===\n\n")
cat("Dataset dimensions:", nrow(protein_matrix), "proteins x",
    ncol(protein_matrix), "samples\n")
cat("Total missing values:", sum(is.na(protein_matrix)),
    "(", round(mean(is.na(protein_matrix)) * 100, 1), "%)\n")
cat("Samples:", paste(sample_metadata$sample_id, collapse = ", "), "\n")
cat("Conditions:", paste(unique(sample_metadata$condition), collapse = ", "), "\n")
cat("Batches:", paste(unique(sample_metadata$batch), collapse = ", "), "\n\n")
# 2. Top 10 most variable proteins
protein_variance <- apply(filtered_matrix, 1, var, na.rm = TRUE)
top10_variable <- names(sort(protein_variance, decreasing = TRUE)[1:10])
cat("Top 10 most variable proteins:\n")
print(top10_variable)
# Plot top variable proteins
top10_data <- protein_long %>%
  filter(protein_id %in% top10_variable)

top10_data <- top10_data |>
  mutate(
    sample_id = factor(
      sample_id,
      levels = top10_data |>
        arrange(condition, timepoint_days) |>
        pull(sample_id) |> 
        unique()
    )
  )

ggplot(top10_data, aes(x = sample_id, y = abundance, color = condition, group = 1)) +
  geom_line() +
  geom_point() +
  facet_wrap(~ protein_id, scales = "free_y", ncol = 2) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Top 10 Most Variable Proteins", x = "Sample", y = "Abundance")
# 3. Clustering by condition
cat("\n3. Checking sample clustering by condition:\n")
cat("Review the PCA and hierarchical clustering plots above.\n")
cat("Samples should cluster primarily by condition if biological signal is strong.\n")
```

## Creating Quality Control Reports

```{r qc-report}
# Function to generate QC report
generate_qc_report <- function(data_matrix, metadata) {
  report <- list()
 
  # Basic statistics
  report$n_proteins <- nrow(data_matrix)
  report$n_samples <- ncol(data_matrix)
  report$missing_pct <- mean(is.na(data_matrix)) * 100
 
  # Sample statistics
  report$sample_stats <- data.frame(
    Sample = colnames(data_matrix),
    N_Quantified = colSums(!is.na(data_matrix)),
    Median_Abundance = apply(data_matrix, 2, median, na.rm = TRUE),
    Mean_Abundance = apply(data_matrix, 2, mean, na.rm = TRUE),
    SD_Abundance = apply(data_matrix, 2, sd, na.rm = TRUE)
  )
 
  # Protein statistics
  report$protein_stats <- data.frame(
    N_Complete = sum(rowSums(is.na(data_matrix)) == 0),
    N_Partial = sum(rowSums(is.na(data_matrix)) > 0 & rowSums(is.na(data_matrix)) < ncol(data_matrix)),
    N_Mostly_Missing = sum(rowSums(is.na(data_matrix)) > ncol(data_matrix) * 0.5)
  )
 
  return(report)
}
# Generate report
qc_report <- generate_qc_report(protein_matrix, sample_metadata)
# Print report
cat("=== QUALITY CONTROL SUMMARY ===\n\n")
cat("Total Proteins:", qc_report$n_proteins, "\n")
cat("Total Samples:", qc_report$n_samples, "\n")
cat("Missing Data:", round(qc_report$missing_pct, 2), "%\n\n")
cat("Protein Completeness:\n")
cat(" Complete (no missing):", qc_report$protein_stats$N_Complete, "\n")
cat(" Partial missing:", qc_report$protein_stats$N_Partial, "\n")
cat(" Mostly missing (>50%):", qc_report$protein_stats$N_Mostly_Missing, "\n\n")
print(qc_report$sample_stats)
```
